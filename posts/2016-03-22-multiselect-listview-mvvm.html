<!DOCTYPE html>
<html lang=""  itemscope itemtype="http://schema.org/Blog">
<head>
        <!–– Made with Lockdown: https://github.com/fferegrino/lockdown ––>
<meta charset="utf-8" />
<link rel="stylesheet" href="/css/main.css" />

        
</head>

<body>  
        <header class="site-header ui">
    <div class="wrapper menu">
      <nav class="site-nav">
        <a href="#" class="menu-icon">
          <svg viewBox="0 0 18 15">
            <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
            <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
            <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
          </svg>
        </a>
        <div class="trigger">
          <a class="link page-link" href="/">Home</a>
          <a class="link page-link" href="/about">About</a>
          <a class="link page-link" href="/search">Search</a>
        </div>
      </nav>
    </div>
    <div class="wrapper title">
      <div class="pure-g">
        <div class="pure-u-1-24 title-number"><span>1</span></div>
        <div class="pure-u-11-24 content-window">
          <a class="site-title" href="/">That C# guy</a>
        </div>
        <div class="pure-u-12-24 header-menu">
          <ul>
            <li class="datascience"><a href="/tag/data-science/">Data Science!</a></li>
            <li class="youtube"><a href="https://www.youtube.com/c/thatcsharpguy">YouTube<a></li>
            <li class="csharp"><a href="/tag/aprendecsharp/">Aprende C#</a></li>
            <li class="xamarin"><a href="/tag/xamarin/">Xamarin</a></li>
          </ul>
        </div>
      </div>
  
  </header>
        <div class="page-content">
            <div class="wrapper">
                
<h1></h1>

<p>Por fin he vuelto a desarrollar algo con Xamarin.Forms y parte de lo que he tenido que hacer tuvo que ver con implementar una lista que permitiera la selección múltiple de filas y fuera compatible con el patrón MVVM.</p>
<p>Investigando un poco encontré que el control <code>ListView</code>, que es el más usado para mostrar datos en forma de lista, no permite la selección múltiple y que habría que hacerlo de otra manera. Dentro de la documentación de Xamarin también <a href="https://developer.xamarin.com/recipes/cross-platform/xamarin-forms/controls/multiselect/" target="_blank" rel="nofollow">este artículo</a> en el que explica una forma de hacerlo y en ese está basado este post.</p>
<p>Para llevar a cabo la tarea, debemos tomar en cuenta que necesitaremos de algunas clases auxiliares que explicaré a detalle más adelante.</p>
<h3 id="el-modelo">El modelo</h3>
<p>Para este ejemplo vamos a mostrar una lista de Pokemons y permitiremos al usuario seleccionar varios de ellos a través de una lista, la clase de nuestro modelo es la siguiente:</p>
<pre><code class="language-csharp">public class Pokemon 
{
    public int Id { get; set; }
    public string Name { get; set; }
    public double Weight { get; set; }
    public double Height { get; set; }
}
</code></pre>
<h3 id="selectableitemwrappert">SelectableItemWrapper&lt;T&gt;</h3>
<p>Adicionalmente al modelo, también es necesario esta clase auxiliar que como el nombre lo indica, es una envoltura para nuestro modelo, la definición es la siguiente:</p>
<pre><code class="language-csharp">public class SelectableItemWrapper&lt;T&gt;
{
    public bool IsSelected { get; set; }
    public T Item { get; set; }
}
</code></pre>
<p>La propiedad <code>IsSelected</code> servirá para determinar si el usuario seleccionó el ítem o no, mientras que <code>Item</code> contendrá el modelo.</p>
<h2 id="la-vista">La vista</h2>
<p>(If you prefer to work with XAML, <a href="//thatcsharpguy.com/post/multiselect-listview-mvvm-en">see this post</a>)</p>
<p>Usaremos dos páginas de Forms, una donde mostraremos todos los Pokemon y otra donde se mostrarán únicamente los que el usuario eligió.</p>
<p>Para la primera, donde estarán todos los Pokemon, debemos modificar un poco la forma en la que estamos acostumbrados a crear los templates para las celdas de la lista, y es que necesitamos tomar en cuenta que cada fila de la lista estará ligado a un <code>SelectableItemWrapper&lt;Pokemon&gt;</code> y no a un <code>Pokemon</code>.</p>
<p>Declararemos la lista y pondremos la colección <code>Pokemons</code>, definida más adelante en el ViewModel, como la fuente de ítems:</p>
<pre><code class="language-csharp">var list = new ListView();
list.SetBinding(ListView.ItemsSourceProperty, &quot;Pokemons&quot;);
</code></pre>
<p>Como sabemos, ahora cada uno de los elementos de la colección será una celda en la lista.</p>
<h4 id="pokemonselectablecell">PokemonSelectableCell</h4>
<p>Para esta celda es necesario que se muestre el nombre, el peso y la altura, además de un control para permitir que dicho pokemon sea seleccionable, es por eso que se crean las propiedades <em>bindeables</em> necesarias.</p>
<p>Es por eso que se crean tres etiquetas para mostrar la información y en este caso se hará uso de <code>Switch</code>, que llamaremos <code>sw</code>, para marcar la selección de cada uno (intenté usar el <a href="https://github.com/XLabs/Xamarin-Forms-Labs/wiki/Checkbox-Control" target="_blank" rel="nofollow">CheckBox de XLabs</a>, pero encontré un pequeño bug con las listas).</p>
<p>Tu puedes diseñar tu celda como quieras, pero es importante que dentro de ella <em>bindees</em> o ligues una propiedad booleana, como <code>IsToggled</code> o <code>Checked</code>, a la propiedad <code>IsSelected</code> de la clase <code>SelectableItemWrapper</code>. Bastará con una línea así:</p>
<pre><code class="language-csharp">// Important:
sw.SetBinding(Switch.IsToggledProperty, &quot;IsSelected&quot;);
</code></pre>
<p>Es importante señalar que dicho <em>binding</em> está definido en la implementación de la celda y no en el código de la vista.</p>
<h3 id="volviendo-a-la-vista">Volviendo a la vista</h3>
<p>Ya de vuelta en la vista, podemos hacer uso de la celda en nuestra <code>ListView</code>, podemos definir los otros <em>bindings</em>:</p>
<pre><code class="language-csharp">var template = new DataTemplate(typeof(PokemonSelectableCell));
template.SetBinding(PokemonSelectableCell.NameProperty, &quot;Item.Name&quot;);
template.SetBinding(PokemonSelectableCell.WeightProperty, &quot;Item.Weight&quot;);
template.SetBinding(PokemonSelectableCell.HeightProperty, &quot;Item.Height&quot;);
list.ItemTemplate = template;
</code></pre>
<p>Podrás notar que la ruta del <em>binding</em> no es &quot;directa&quot;, si no que primero nos estamos refiriendo a la propiedad <code>Item</code> y luego a las propiedades &quot;reales&quot; y esto es porque estamos <em>bindeando</em> un <code>SelectableItemWrapper&lt;Pokemon&gt;</code> y no una instancia de <code>Pokemon</code>.</p>
<h3 id="el-viewmodel">El ViewModel</h3>
<p>Para el ViewModel requeriremos dos colecciones:</p>
<ul>
<li>Una para contener una lista de todos los elementos</li>
<li>Una para contener los elementos seleccionados</li>
</ul>
<p>Sus definiciones son las siguientes:</p>
<pre><code class="language-csharp">private ObservableCollection&lt;SelectableItemWrapper&lt;Pokemon&gt;&gt; _pokemons;
public ObservableCollection&lt;SelectableItemWrapper&lt;Pokemon&gt;&gt; Pokemons
{
    get { return _pokemons; }
    set { _pokemons = value; RaisePropertyChanged(); }
}

private ObservableCollection&lt;Pokemon&gt; _selectedPokemons;
public ObservableCollection&lt;Pokemon&gt; SelectedPokemons
{
    get { return _selectedPokemons; }
    private set { _selectedPokemons = value; RaisePropertyChanged(); }
}
</code></pre>
<p>La primera, <code>Pokemons</code> es una <code>ObservableCollection</code> de <code>SelectableItemWrapper</code> de <code>Pokemon</code> ya que es la contiene los elementos que serán seleccionables. Mientras que la segunda es una colección como cualquier otra.</p>
<p>Entonces, en el ViewModel podemos obtener todos los elementos seleccionados usando Linq:</p>
<pre><code class="language-csharp">ObservableCollection&lt;Pokemon&gt; GetSelectedPokemons()
{
    var selected = Pokemons
        .Where(p =&gt; p.IsSelected)
        .Select(p =&gt; p.Item)
        .ToList();   
    return new ObservableCollection&lt;Pokemon&gt;(selected);
}
</code></pre>
<p>Marcar o desmarcar todos los elementos como seleccionados:</p>
<pre><code class="language-csharp">void SelectAll(bool select)
{
    foreach (var p in Pokemons)
    {
        p.IsSelected = select;
    }
}
</code></pre>
<p>Y todo, desde el ViewModel. Recuerda, puedes <a href="https://github.com/ThatCSharpGuy/MultiPokeList" target="_blank">ver el código fuente</a>. Y también puedes ver un ejemplo de la app terminada:</p>
<img src="http://i.giphy.com/qpfRFj3MrFqow.gif" title="Multi-select ListView y MVVM" />
<h4 id="creditos">Créditos</h4>
<p>La clase <code>SelectMultipleBasePage&lt;T&gt;</code> en la que está completamente basada la información de este post, fue escrita por Glenn Stephens de la  Xamarin University, <a href="https://developer.xamarin.com/recipes/cross-platform/xamarin-forms/controls/multiselect/" target="_blank" rel="nofollow">mira el post original</a>.</p>


            </div>
          </div>
        
</body>
</html>
