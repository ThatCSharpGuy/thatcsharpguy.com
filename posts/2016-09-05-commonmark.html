<!DOCTYPE html>
<html lang=""  itemscope itemtype="http://schema.org/Blog">
<head>
        <!–– Made with Lockdown: https://github.com/fferegrino/lockdown ––>
<meta charset="utf-8" />
<link rel="stylesheet" href="/css/main.css" />

        
</head>

<body>  
        <header class="site-header ui">
    <div class="wrapper menu">
      <nav class="site-nav">
        <a href="#" class="menu-icon">
          <svg viewBox="0 0 18 15">
            <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
            <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
            <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
          </svg>
        </a>
        <div class="trigger">
          <a class="link page-link" href="/">Home</a>
          <a class="link page-link" href="/about">About</a>
          <a class="link page-link" href="/search">Search</a>
        </div>
      </nav>
    </div>
    <div class="wrapper title">
      <div class="pure-g">
        <div class="pure-u-1-24 title-number"><span>1</span></div>
        <div class="pure-u-11-24 content-window">
          <a class="site-title" href="/">That C# guy</a>
        </div>
        <div class="pure-u-12-24 header-menu">
          <ul>
            <li class="datascience"><a href="/tag/data-science/">Data Science!</a></li>
            <li class="youtube"><a href="https://www.youtube.com/c/thatcsharpguy">YouTube<a></li>
            <li class="csharp"><a href="/tag/aprendecsharp/">Aprende C#</a></li>
            <li class="xamarin"><a href="/tag/xamarin/">Xamarin</a></li>
          </ul>
        </div>
      </div>
  
  </header>
        <div class="page-content">
            <div class="wrapper">
                
<h1></h1>

<p>De nuevo un <a href="#">#NuGetRecomendado</a>, esta vez hablaré de uno que tiene un caso muy específico de uso.</p>
<p>Seguramente habrás escuchado sobre Markdown, que es un lenguaje de marcado entendible fácilmente para los humanos (a diferencia de XML). Este lenguaje es principalmente usado para la creación de documentos HTML a partir de otros con el formato Markdown.</p>
<p>El formato fue creado por <a href="https://web.archive.org/web/20040402080322/http://www.aaronsw.com/weblog/001189" target="_blank">John Gruber y Aaron Swartz</a> con la idea de tener una forma sencilla de escribir un email, un post de blog (como este que estás leyendo), una respuesta en un foro o sitio web, usando una <a href="https://daringfireball.net/projects/markdown/syntax" target="_blank">sintaxis simple</a> y no tan invasiva con el documento. Una vez escrito el documento es necesario hacerlo pasar por un proceso de conversión a HTML.</p>
<p>Este NuGet realiza precisamente eso: la conversión de Markdown a HTML.</p>
<h2 id="codigo">Código</h2>
<p>Para el siguiente ejemplo, vamos a trabajar con el archivo llamado <code>input.md</code> cuyo contenido es:</p>
<pre>
Hello world
=  

Visita el post del [blog](http://thatcsharpguy.com/post/commonmark) para **saber más** sobre *CommonMark.NET*  
</pre>    
<h3 id="convert-strings">Convert (Strings)</h3>
<p>Si lo único que quieres es convertir En realidad la api de CommonMark es una de las más sencillas, el siguiente bloque de código convierte una cadena de texto (Markdown) en otra cadena de texto (HTML):</p>
<pre><code class="language-csharp">var file = File.ReadAllText(&quot;input.md&quot;);
var exp = CommonMark.CommonMarkConverter.Convert(file);
Console.WriteLine(exp);
</code></pre>
<p>El resultado:</p>
<pre>
&lt;h1&gt;Hello world&lt;/h1&gt;
&lt;p&gt;Visita el post del &lt;a href=&quot;http://thatcsharpguy.com/post/commonmark&quot;&gt;blog&lt;/a&gt; para &lt;strong&gt;saber m&#225;s&lt;/strong&gt; sobre &lt;em&gt;CommonMark.NET&lt;/em&gt;&lt;/p&gt;
</pre>
<h3 id="convert-streams">Convert (Streams)</h3>
<p>Habrá ocasiones en las que necesitemos convertir archivos completos y hacerlo usando <em>streams</em> de datos, para esto, el método <code>Convert</code> tiene otra sobrecarga que permite realizar esta tarea. Previamente necesitamos abrir los flujos de datos (yo recomiendo hacerlo con <a href="../usos-using-2">el bloque using</a>):</p>
<pre><code class="language-csharp">using (var reader = new StreamReader(&quot;input.md&quot;))
using (var writer = new StreamWriter(&quot;output.html&quot;))
{
    CommonMark.CommonMarkConverter.Convert(reader, writer);
}
</code></pre>
<p>Tras lo cual, si abrimos el archivo <code>output.html</code> con un navegador, veremos algo como lo siguiente:</p>
<p>&lt;img src=&quot;/images/commonmark__raw_output.png&quot; title=<>Salida</> /&gt;</p>
<p>Sin embargo, de esta forma lo único que estamos haciendo es escribiendo algunas etiquetas HTML en el documento de salida, falta escribir los tags <code>html</code>, <code>head</code>, <code>body</code>... entre otros para que el HTML sea válido.</p>
<h3 id="convert-conversion-personalizada">Convert (conversión personalizada)</h3>
<p>Para nuestra suerte, el desarrollador de CommonMark, nos permite configurar la forma en la que se <em>renderea</em>
el resultado de la conversión. Esto, a través de la clase <code>CommonMarkSettings</code> y un derivado de <code>HtmlFormatter</code>:</p>
<pre><code class="language-csharp">class CustomHtmlFormatter : CommonMark.Formatters.HtmlFormatter
{
    // ... 
</code></pre>
<h4 id="writeinline">WriteInline</h4>
<p>El método <code>WriteInline</code>, que permite modificar la manera en que se <em>renderea</em> un elemento en HTML. en el ejemplo siguiente se modifica la forma en la que se escriben las etiquetas <code>a</code> para que los enlaces se abran en una nueva pestaña:</p>
<pre><code class="language-csharp">    protected override void WriteInline(Inline inline, bool isOpening, bool isClosing, out bool ignoreChildNodes)
    {
        if (inline.Tag == InlineTag.Link) // Es enlace
        {
            ignoreChildNodes = false; // Queremos seguir procesando los nodos hijo

            //  Revisamos si es la etiqueta de apertura
            if (isOpening)
            {
                this.Write(&quot;&lt;a target=\&quot;_blank\&quot; href=\&quot;&quot;);
                this.WriteEncodedUrl(inline.TargetUrl);
                this.Write(&quot;\&quot;&gt;&quot;);
            }

            //  Revisamos si es la etiqueta de cierre
            if (isClosing)
            {
                this.Write(&quot;&lt;/a&gt;&quot;);
            }
        }
        else
        {
            // Usamos la implementación por default para otro los otros nodos
            base.WriteInline(inline, isOpening, isClosing, out ignoreChildNodes);
        }
    }
</code></pre>
<h4 id="writeblock">WriteBlock</h4>
<p>Pero esta es solo una opción de configuración, ya que por otro lado podemos sobrescribir el método <code>WriteBlock</code> para escribir bloques completos. En este caso, usaremos el método para escribir un documento HTML válido:</p>
<pre><code class="language-csharp">    protected override void WriteBlock(Block block, bool isOpening, bool isClosing, out bool ignoreChildNodes)
    {
        // Si es un tag de apertura y es Document
        if (isOpening &amp;&amp; block.Tag == BlockTag.Document)
        {
            this.Write(&quot;&lt;html&gt;&quot;);
            this.Write(&quot;&lt;head&gt;\n&lt;meta charset=\&quot;UTF-8\&quot;&gt;\n&lt;link href=\&quot;https://github.com/jasonm23/markdown-css-themes/raw/gh-pages/markdown6.css\&quot; rel=\&quot;stylesheet\&quot; &gt;&lt;/head&gt;&quot;);
            this.Write(&quot;&lt;body&gt;&quot;);
        }
        // Si es un tag de cierre y es Document
        else if (isClosing &amp;&amp; block.Tag == BlockTag.Document)
        {
            this.Write(&quot;&lt;/body&gt;&lt;/html&gt;&quot;);
        }

        // LLamamos a la implementación por default para procesar los otros nodos
        base.WriteBlock(block, isOpening, isClosing, out ignoreChildNodes);
    }
</code></pre>
<p>Tras lo cual, podrías tener algo como esto:</p>
<p>&lt;img src=&quot;/images/commonmark__raw_output_2.png&quot; title=<>Salida</> /&gt;</p>
<p>Gran diferencia, ¿no?</p>
<h2 id="casos-de-uso">Casos de uso</h2>
<p>Esta librería tiene una tarea en específico, y tal vez te resulte complicado encontrarle un uso, pero si como yo, estás <a href="#" target="_blank">creando un visor de Markdown</a> o, estás creando tu <a href="https://davidwalsh.name/introduction-static-site-generators" target="_blank">generador de sitios estáticos</a> (el blog usa jekyll, pero he pensado en crear un generador con C#).</p>
<h2 id="conclusion">Conclusión</h2>
<p>Como pudiste observar, la API de CommonMark.NET es bastante sencilla de aprender y usar, en donde la cosa se puede tornar un poco complicada es cuando queremos personalizar el resultado final mediante la clase <code>CommonMarkSettings</code>.</p>
<h1 id="instalacion">Instalación</h1>
<p>En el gestor de paquetes de NuGet: <code>CommonMark.NET</code></p>
<p>O desde la consola:</p>
<pre><code>PM&gt; Install-Package CommonMark.NET
</code></pre>
<p>Y al igual que con todos los NuGets, no olvides revisar el código fuente de <em>CommonMark.NET</em> <a href="https://github.com/Knagis/CommonMark.NET" target="_blank" >en GitHub</a>, en donde encontrarás gran parte de la <a href="https://github.com/Knagis/CommonMark.NET/blob/master/CommonMark/Formatters/HtmlFormatter.cs" target="_blank">documentación en el código</a>, lo cual es absolutamente fantástico.</p>


            </div>
          </div>
        
</body>
</html>
