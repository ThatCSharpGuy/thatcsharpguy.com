<!DOCTYPE html>
<html lang=""  itemscope itemtype="http://schema.org/Blog">
<head>
        <!–– Made with Lockdown: https://github.com/fferegrino/lockdown ––>
<meta charset="utf-8" />
<link rel="stylesheet" href="/css/main.css" />

        
</head>

<body>  
        <header class="site-header ui">
    <div class="wrapper menu">
      <nav class="site-nav">
        <a href="#" class="menu-icon">
          <svg viewBox="0 0 18 15">
            <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
            <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
            <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
          </svg>
        </a>
        <div class="trigger">
          <a class="link page-link" href="/">Home</a>
          <a class="link page-link" href="/about">About</a>
          <a class="link page-link" href="/search">Search</a>
        </div>
      </nav>
    </div>
    <div class="wrapper title">
      <div class="pure-g">
        <div class="pure-u-1-24 title-number"><span>1</span></div>
        <div class="pure-u-11-24 content-window">
          <a class="site-title" href="/">That C# guy</a>
        </div>
        <div class="pure-u-12-24 header-menu">
          <ul>
            <li class="datascience"><a href="/tag/data-science/">Data Science!</a></li>
            <li class="youtube"><a href="https://www.youtube.com/c/thatcsharpguy">YouTube<a></li>
            <li class="csharp"><a href="/tag/aprendecsharp/">Aprende C#</a></li>
            <li class="xamarin"><a href="/tag/xamarin/">Xamarin</a></li>
          </ul>
        </div>
      </div>
  
  </header>
        <div class="page-content">
            <div class="wrapper">
                
<h1></h1>

<p>En la actualidad la mayoría de las apps que conocemos tienen alguna interacción con internet: ya sea para realizar publicaciones a Facebook o Twitter, para recuperar información acerca del clima o el tráfico o para actualizar tu puntuación en un juego.</p>
<p>Es por eso que seguramente las aplicaciones que tu desarrolles también tengan que incluir esta interacción... y mientras que podrías tu mismo programar toda la infraestructura para realizar peticiones, ¿por qué no usar una librería que ya lo hace? En este post te voy a hablar de Flurl y Flurl.Http, que son librerías con una api fluida que facilitan la escritura y ejecución de peticiones HTTP.</p>
<h2 id="construccion-de-urls">Construcción de URLs</h2>
<p>De entrada, podría parecerte sencillo crear URLs por tu cuenta, pero cuando menos te das cuenta resulta que olvidaste poner un '/' y todo el código está mal. Con Flurl te puedes olvidar de esos problemas:</p>
<p>El método <code>AppendPathSegment</code> ayuda a añadir un segmento de URL a otra, al ser una api fluida, podemos <em>encadenar</em> varias llamadas a <code>AppendPathSegment</code>:</p>
<pre><code class="language-csharp"> var myCoolUrl2 = &quot;http://localhost/&quot;
    .AppendPathSegment(&quot;sales&quot;)
    .AppendPathSegment(&quot;Q1&quot;)
    .AppendPathSegment(&quot;max&quot;);
Console.WriteLine(myCoolUrl2);
</code></pre>
<p>Al final, <code>myCoolUrl2</code> es:</p>
<pre>
http://localhost/sales/Q1/max
</pre> 
<p>El método devuelve un objeto del tipo <code>Url</code>, sobre el que podemos trabajar y que es directamente transformable en una cadena de texto.</p>
<p>Si lo que necesitamos es añadir muchos segmentos a una URL, tal vez sea más conveniente hacerlo a través de un arreglo, tal vez sea mejor usar <code>AppendPathSegments</code>. Este método es similar al anterior, solo que opera con un mútliples segmentos de URL que son enviados en un arreglo marcado <a href="/params-c-sharp">como params</a>:</p>
<pre><code class="language-csharp">var urlParts = new string[] { &quot;liga_mx&quot;, &quot;results&quot;, &quot;america&quot; };
var builtUrl2 = new Url(&quot;http://api.soccer-data.com&quot;);
builtUrl2.AppendPathSegments(urlParts);
Console.WriteLine(builtUrl2);
</code></pre>
<p>Al final, <code>builtUrl2</code> es:</p>
<pre>
http://api.soccer-data.com/liga_mx/results/america
</pre> 
<h3 id="query-string">Query string</h3>
<p>Flurl también tiene la capacidad de añadir parámetros a la <em>query string</em> de una URL usando el método <code>SetQueryParams</code>, para lo cual se crea un objeto anónimo:</p>
<pre><code class="language-csharp">var endDate = DateTime.Today;
var startDate = endDate.AddDays(-30);
builtUrl.SetQueryParams(new { endDate, startDate, c = &quot;concacaf champions league&quot; });
Console.WriteLine(builtUrl);
</code></pre>
<p>Al final, <code>builtUrl</code> es:</p>
<pre>
http://api.soccer-data.com/liga_mx/results/america?endDate=04%2F25%2F2016%2000%3A00%3A00&startDate=03%2F26%2F2016%2000%3A00%3A00&c=concacaf%20champions%20league
</pre> 
<p>Como puedes darte cuenta, los nombres de las propiedades en el objeto anónimo <code>new { endDate, startDate, c = competition }</code> fueron respetadas y los parámetros fueron codificados como URL para ser enviados en una petición HTTP.</p>
<p>También podemos quitar parámetros de la <em>query string</em> con <code>RemoveQueryParams</code>:</p>
<pre><code class="language-csharp">builtUrl.RemoveQueryParams(&quot;c&quot;, &quot;startDate&quot;);
Console.WriteLine(builtUrl);
</code></pre>
<p>Al final, <code>builtUrl</code> es:</p>
<pre>
http://api.soccer-data.com/liga_mx/results/america?endDate=04%2F25%2F2016%2000%3A00%3A00
</pre> 
<h2 id="creacion-de-un-cliente-http">Creación de un cliente HTTP</h2>
<p>A partir de tener una URL construida con los métodos anteriores, podemos comenzar a configurar nuestro cliente HTTP:</p>
<pre><code class="language-csharp">var client = myCoolUrl1
    .WithBasicAuth(&quot;antonio&quot;, &quot;secretPass&quot;)
    .WithHeader(&quot;User-Agent&quot;, &quot;Flurl-Sample&quot;);
</code></pre>
<p>Ahora, cada vez que hagamos una petición con un cliente creado por esta URL, contendrá el encabezado siguiente:</p>
<pre>
Authorization: Basic YW50b25pbzpzZWNyZXRQYXNz  
User-Agent: Flurl-Sample
</pre> 
<p>También tenemos más opciones, como la de asignar varios encabezados a la vez:</p>
<pre><code class="language-csharp">var client2 = builtUrl
    .WithOAuthBearerToken(&quot;t0k3n&quot;)
    .WithHeader(&quot;Accept-Language&quot;, &quot;it&quot;)
    .WithHeader(&quot;User-Agent&quot;, &quot;Flurl-Sample&quot;)
    .WithHeaders(new
    {
        CustomHeader = &quot;Another value&quot;,
        Accept = &quot;text/json&quot;
    });
</code></pre>
<p>Cuyo resultado es:</p>
<pre>
Authorization: Bearer t0k3n  
Accept-Language: it  
User-Agent: Flurl-Sample  
CustomHeader: Another value  
Accept: text/json  
</pre> 
<h2 id="ejecucion-de-peticiones">Ejecución de peticiones</h2>
<p>Ya sea con un cliente HTTP o con una Url podemos comenzar a realizar peticiones asíncronas. Para este ejemplo, usaré la <a href="http://pokeapi.co/" target="_blank">Pokéapi</a>:</p>
<pre><code class="language-csharp">var pokemonId = 25;
var url1 = &quot;http://pokeapi.co/api/v2/&quot;
    .AppendPathSegment(&quot;pokemon&quot;)
    .AppendPathSegment(pokemonId.ToString());

Console.WriteLine(&quot;Consultando &quot; + url1); // Consultando http://pokeapi.co/api/v2/pokemon/25
</code></pre>
<p>A partir de aquí podemos obtener un objeto dinámico con <code>GetJsonAsync</code>:</p>
<pre><code class="language-csharp">dynamic pkmn1 = await url1.GetJsonAsync(); // pkmn1 
Console.WriteLine(pkmn1.name + &quot; &quot; + &quot;\nH:&quot; + pkmn1.height + &quot;\nW:&quot; + pkmn1.weight + &quot;\n&quot;);
</code></pre>
<pre>
pikachu
H:4
W:60
</pre>
<p>O crear una clase que contenga las propiedades del objeto que vamos a recibir para que el resultado que tenemos sea fuertemente tipado, usando <code>GetJsonAync&lt;T&gt;</code> :</p>
<pre><code class="language-csharp">var pokemon = await url2.GetJsonAsync&lt;Pokemon&gt;();
Console.WriteLine(pokemon.Name + &quot;\nH:&quot; + pokemon.Height + &quot;\nW:&quot; + pokemon.Weight + &quot;\n&quot;);
</code></pre>
<pre>
charmander
H:6
W:85
</pre>
<p>Flurl también permite hacer peticiones POST mediante <code>PostJsonAsync</code> o <code>PostUrlEncodedAsync</code>, además de integrar el manejo de errores mediante la <code>FlurlHttpException</code> que contiene la información necesaria acerca del error sucedido, por ejemplo, mira el manejo de esta excepción</p>
<pre><code class="language-csharp">catch (FlurlHttpException ex)
{
    if (ex.Call.Response != null
        &amp;&amp; ex.Call.Response.StatusCode == HttpStatusCode.NotFound)
    {
        Console.WriteLine(&quot;No existe un pokemon llamado &quot; + pokemonName);
    }
}
</code></pre>
<p>No olvides que puedes consultar todo el código de este ejemplo en <a href="https://github.com/ThatCSharpGuy/Flurl-Sample" target="_blank">https://github.com/ThatCSharpGuy/Flurl-Sample</a>.</p>
<h2 id="conclusion">Conclusión</h2>
<p>Al principio pareciera que la construcción de URLs, configuración de clientes y ejecución de peticiones HTTP es tan sencillo que tu mismo puedes gestionarlo todo, pero depende del tamaño de lo que quieres lograr. Si tu interés es delegar esta tarea a librerías de terceros, Flurl es una gran opción y es que además de lo poco que traté de mostrar en este post, aún hay más, entre ellas la facilidad que nos brinda a la hora de hacer <em>testing</em>.</p>
<h1 id="instalacion">Instalación</h1>
<p>Para instalarlo no hay mejor manera que el gestor de paquetes de NuGet, instala solo Flurl si quieres solo los beneficios de la construcción de URLs o Flurl.Http si quieres el paquete completo:</p>
<pre><code>PM&gt; Install-Package Flurl
</code></pre>
<pre><code>PM&gt; Install-Package Flurl.Http
</code></pre>
<p>O échale un ojo al <a href="https://github.com/tmenier/Flurl" target="_blank" rel="nofollow">proyecto en GitHub</a> y contribuir a su desarrollo de alguna manera.</p>


            </div>
          </div>
        
</body>
</html>
