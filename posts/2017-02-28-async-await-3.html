<!DOCTYPE html>
<html lang=""  itemscope itemtype="http://schema.org/Blog">
<head>
        <!–– Made with Lockdown: https://github.com/fferegrino/lockdown ––>
<meta charset="utf-8" />
<link rel="stylesheet" href="/css/main.css" />

        
</head>

<body>  
        <header class="site-header ui">
    <div class="wrapper menu">
      <nav class="site-nav">
        <a href="#" class="menu-icon">
          <svg viewBox="0 0 18 15">
            <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
            <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
            <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
          </svg>
        </a>
        <div class="trigger">
          <a class="link page-link" href="/">Home</a>
          <a class="link page-link" href="/about">About</a>
          <a class="link page-link" href="/search">Search</a>
        </div>
      </nav>
    </div>
    <div class="wrapper title">
      <div class="pure-g">
        <div class="pure-u-1-24 title-number"><span>1</span></div>
        <div class="pure-u-11-24 content-window">
          <a class="site-title" href="/">That C# guy</a>
        </div>
        <div class="pure-u-12-24 header-menu">
          <ul>
            <li class="datascience"><a href="/tag/data-science/">Data Science!</a></li>
            <li class="youtube"><a href="https://www.youtube.com/c/thatcsharpguy">YouTube<a></li>
            <li class="csharp"><a href="/tag/aprendecsharp/">Aprende C#</a></li>
            <li class="xamarin"><a href="/tag/xamarin/">Xamarin</a></li>
          </ul>
        </div>
      </div>
  
  </header>
        <div class="page-content">
            <div class="wrapper">
                
<h1></h1>

<p>Una vez que conocimos los tipos <code>Task</code> y las apalabras <code>async</code> y <code>await</code>, y cómo es que nos ayudan a ejecutar código de manera asíncrona, es momento de comenzar a extender este poder para sacarle más ventaja.</p>
<p>En este post veremos cómo es que podemos ejecutar tareas asíncronas de manera paralela. Ojo que el paralelelismo conlleva más complicaciones, pero este es un buen lugar para comenzar.</p>
<h2 id="ejemplo">Ejemplo</h2>
<p>Nuevamente para seguir trabajando con este post tal vez quieras descargar la aplicación <a href="https://github.com/ThatCSharpGuy/AsyncAwait" target="_blank">demo que puedes encontrar en GitHub</a>. Para demostrar cómo podemos cancelar las tareas vamos a hacer uso deuna <code>ProgressBar</code> y unos cuantos botones. En este caso vamos a crear una tarea infinita que moverá de 0 a 100% la barra de progreso, esta es la tarea que vamos a cancelar con las técnicas que veremos en este post:</p>
<pre><code class="language-csharp">public static async Task SlowTask(IProgress&lt;double&gt; progress, CancellationToken token)
{
    while (true)
    {
        for (int i = 0; i &lt; 100; i++)
        {
            await Task.Delay(10);
            // ???
            progress.Report(i / 100d);
        }
        for (int i = 100; i &gt; 0; i--)
        {
            await Task.Delay(10);
            // ???
            progress.Report(i / 100d);
        }
    }
}
</code></pre>
<p>Un momento... aquí hay un par de cosas nuevas: La interfaz <code>IProgress&lt;T&gt;</code> y  la clase <code>CancellationToken</code>, comenzaremos por la primera.</p>
<h2 id="iprogress">IProgress<T></h2>
<p>Probablemente quieras separar tu código en varias capas, dejando en librerías separadas la capa de la interfaz y la capa de lógica. Pero, ¿en este escenario cómo podrías actualizar la <em>UI</em> desde una <code>Task</code>?</p>
<p>Lo primero que se te podría ocurrir es usar <a href="..\delegados-en-c-sharp" target="_blank">delegados</a>, o alguna <a href="..\func-y-action-en-c-sharp" target="_blank"><code>Action</code></a> para &quot;inyectar&quot; código dentro de la tarea. Pero por otro lado podríamos hacer uso de la interfaz <code>IProgress&lt;T&gt;</code> del framework.</p>
<p>Esta interfaz define un solo método: <code>Report</code> que como su nombre lo indica nos sirve para reportar el progreso de una tarea desde una tarea asíncrona. En este caso, en el siguiente código se muestra la implementación de <code>IReport&lt;double&gt;</code> del ejemplo:</p>
<pre><code class="language-csharp">public partial class AdvancedPage : ContentPage, IProgress&lt;double&gt;
{
    public void Report(double value)
    {
        Device.BeginInvokeOnMainThread(() =&gt; 
        {
            ProgressBar.Progress = value;
            IntegerReport.Text = (value * 100).ToString();
        });
    }
</code></pre>
<p>Entonces, para ejecutar la tarea tenemos que llamarla así:</p>
<pre><code class="language-csharp">var task = UltraComplexLibrary.SlowTask(this);
</code></pre>
<p>En donde <code>this</code> es una instancia de la clase <code>AdvancedPage</code>.</p>
<h2 id="cancellationtoken"><code>CancellationToken</code></h2>
<p>Ahora que podemos reportar el progreso de la una tarea asíncrona es probable que en algun momento deseemos cancelar una tarea, ya sea porque el usuario ya no está interesado en el resultado o porque la tarea está tardando mucho tiempo en ejecutarse. Al igual que para reportar el progreso, existen otras formas para cancelar una tarea, sin embargo, la más recomendable es hacer uso de un <code>CancellationToken</code> al cual me referiré de ahora en adelante solamente como <em>token</em>.</p>
<h3 id="cancellationtokensource"><code>CancellationTokenSource</code></h3>
<p>Este tipo de <em>tokens</em> se deben obtener de una <em>fuente</em>, en este caso de la clase <code>CancellationTokenSource</code>. Tanto el <em>token</em> como la <em>fuente</em> están fuertemente relacionadas y no se entiende la existencia de una sin la otra.</p>
<p>Crear una <em>fuente</em> de <em>tokens</em> es sencillo, basta con usar el operador <code>new</code>:</p>
<pre><code class="language-csharp">CancellationTokenSource CancellationTokenSource;
// ...
CancellationTokenSource = new CancellationTokenSource();
</code></pre>
<p>Y para obtener un <em>token</em> es necesario llamar a la propiedad <code>Token</code>, entonces la llamada a nuestra tarea cancelable queda como sigue:</p>
<pre><code class="language-csharp">var task = UltraComplexLibrary.SlowTask(this, CancellationTokenSource.Token);
</code></pre>
<h3 id="cancelando-la-tarea">Cancelando la tarea</h3>
<p>El primer paso para cancelar una tarea es llamar al método <code>Cancel</code> sobre la <em>fuente</em>. Ya sea que lo llamemos directamente nosotros, o especifiquemos que se cancele después de cierta cantidad de tiempo:</p>
<pre><code class="language-csharp">CancellationTokenSource.Cancel();  
CancellationTokenSource.CancelAfter(3000);
</code></pre>
<p>Ahora que dentro de nuestra tarea tenemos un <em>token</em> tenemos dos maneras principales para cancelarla:</p>
<ul>
<li>La primera: Es menos agresiva, es consultar al token si es que se ha solicitado su cancelación mediante la propiedad <code>IsCancellationRequested</code>. La tarea se termina cuando se llega a un <code>return</code>.</li>
</ul>
<pre><code class="language-csharp">if (token.IsCancellationRequested)
    return;
</code></pre>
<ul>
<li>La segunda: que es muy agresiva ya que implica lanzar una excepción si se ha solicitado que el token sea cancelado mediante el método <code>ThrowIfCancellationRequested</code>. La tarea se termina cuando se produce una exepción no controlada.</li>
</ul>
<pre><code class="language-csharp">token.ThrowIfCancellationRequested();
</code></pre>
<p>Si optas por el caso de la excepción no olvides agregar el código pertinente para manejarla en tu código y que no haga que falle por completo tu aplicación.</p>
<p>Usar una excepción o retornar manualmente de una tarea dependerá enteramente de tu criterio y una manera es tan válida como la otra.</p>
<h2 id="para-terminar">Para terminar</h2>
<p>Como puedes ver el cancelar una tarea requiere de un par de componentes extras así como de incluir dentro de la implementación de la tarea la posibilidad de cancelarla. Es por eso que desde un inicio debes valorar si código debe ofrecer la opción de ser cancelado mediante el uso de <em>tokens</em>.</p>
<p>Si estás usando una API de alguien más que no dejó abierta la posibilidad de cancelar la ejecución del código puedes hacer uso de el método <code>Task.WhenAny</code> para &quot;simular&quot; la cancelación. Puedes ver más en esta respuesta de StackOverflow: <a href="http://stackoverflow.com/a/27240225" target="_blank">answer to How can I cancel Task.WhenAll? [VB]</a>.</p>
<blockquote>
<p>Puedes ver mi otro post sobre <a href="..\async-await" target="_blank">cómo crear tareas asíncronas</a> o este otro sobre <a href="..\async-await-2" target="_blank">cómo ejecutar tareas paralelamente</a>.</p>
</blockquote>


            </div>
          </div>
        
</body>
</html>
