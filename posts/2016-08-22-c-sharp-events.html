<!DOCTYPE html>
<html lang=""  itemscope itemtype="http://schema.org/Blog">
<head>
        <!–– Made with Lockdown: https://github.com/fferegrino/lockdown ––>
<meta charset="utf-8" />
<link rel="stylesheet" href="/css/main.css" />

        
</head>

<body>  
        <header class="site-header ui">
    <div class="wrapper menu">
      <nav class="site-nav">
        <a href="#" class="menu-icon">
          <svg viewBox="0 0 18 15">
            <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
            <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
            <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
          </svg>
        </a>
        <div class="trigger">
          <a class="link page-link" href="/">Home</a>
          <a class="link page-link" href="/about">About</a>
          <a class="link page-link" href="/search">Search</a>
        </div>
      </nav>
    </div>
    <div class="wrapper title">
      <div class="pure-g">
        <div class="pure-u-1-24 title-number"><span>1</span></div>
        <div class="pure-u-11-24 content-window">
          <a class="site-title" href="/">That C# guy</a>
        </div>
        <div class="pure-u-12-24 header-menu">
          <ul>
            <li class="datascience"><a href="/tag/data-science/">Data Science!</a></li>
            <li class="youtube"><a href="https://www.youtube.com/c/thatcsharpguy">YouTube<a></li>
            <li class="csharp"><a href="/tag/aprendecsharp/">Aprende C#</a></li>
            <li class="xamarin"><a href="/tag/xamarin/">Xamarin</a></li>
          </ul>
        </div>
      </div>
  
  </header>
        <div class="page-content">
            <div class="wrapper">
                
<h1></h1>

<p>¿Recuerdas que en los primeros posts de este blog hablé sobre <a href="../delegados-en-c-sharp">delegados en C#</a>? pues bien, hoy toca hablar de un pariente muy cercano a ellos: Los eventos o <code>events</code>.</p>
<p>El paso de mensajes entre objetos es uno de los pilares de la programación orientada a objetos, y un evento no es más que eso: un mensaje que se envía de un objeto (el emisor) a otros (los receptores) cada vez que se cumple cierta condición o un cambio ocurre en él.</p>
<p>Los receptores, por su cuenta, se suscriben a los eventos para ser informados cada vez que son <em>lanzados</em> desde el emisor y poder así manejarlos adecuadamente.</p>
<h3 id="declarando-eventos-en-el-emisor">Declarando eventos en el emisor</h3>
<p>Para el código de ejemplo de este post cree una clase llamada <code>Generator</code>, que &quot;genera&quot; números aleatorios cada 0.5 segundos. Supongamos que queremos que la clase nos &quot;avise&quot; a través de un evento cada vez que esté a punto de generar un nuevo número. En C# declaramos eventos de la siguiente manera:</p>
<pre><code class="language-csharp">public delegate void GeneratingNumberEventHandler(Generator sender);

public event GeneratingNumberEventHandler GeneratingNumber;
</code></pre>
<p>En la primera línea de código puedes observar a un viejo conocido, los delegados, en este caso es un delegado que regresa valor alguno y recibe una instancia de <code>Generator</code> como parámetro. Este delegado será el molde para nuestros manejadores de evento.</p>
<p>En la segunda línea se realiza la declaración del evento, la cual se compone de:</p>
<ul>
<li>El modificador de acceso (<code>public</code>, <code>internal</code>, ...).</li>
<li>La palabra reservada <code>event</code>.</li>
<li>El tipo del delegado asociado con ese evento.</li>
<li>El nombre del evento.</li>
</ul>
<h3 id="manejando-los-eventos-en-el-receptor">Manejando los eventos en el receptor</h3>
<p>Para que un receptor esté al pendiente de algún evento en un objeto debe suscribirse a él. La suscripción a los eventos se ejecuta con el operador <code>+=</code> más el <strong>manejador de eventos</strong>, que no es más que un método que cumple con los requisitos del evento:</p>
<p>Por ejemplo, tenemos el siguiente método, que tiene <code>void</code> como valor de retorno y <code>Generator</code> como parámetro (y que por tanto puede ser usado como manjador para el evento declarado arriba):</p>
<pre><code class="language-csharp">static void G_GeneratingNumber(Generator sender)
{
    Console.WriteLine(sender.Name + &quot; generará un número&quot;);
}
</code></pre>
<p>Para asignarlo como manejador, debemos usar el operador <code>+=</code>:</p>
<pre><code class="language-csharp">g = new Generator(name);
g.GeneratingNumber += G_GeneratingNumber;
</code></pre>
<h3 id="invocando-los-eventos-en-el-emisor">Invocando los eventos en el emisor</h3>
<p>Así pues, dentro de nuestro método que genera los números podemos hacer algo como lo siguiente, justamente antes de que se genere un número:</p>
<pre><code class="language-csharp">if (GeneratingNumber!= null)
{
    GeneratingNumber(this);
}
var generated = r.Next();
</code></pre>
<p>Es importante que antes de invocar el evento compruebes que existe al menos un receptor (<code>GeneratingNumber!= null</code>) ya que de otro modo obtendrás una espantosa <code>NullReferenceException</code>.</p>
<p>Tras lo cual, si ejecutas el programa podrás ver algo como esto:</p>
<pre>
Locotrón generará un número  
Locotrón generará un número  
Locotrón generará un número  
</pre>
<h3 id="auxiliares-eventhandler-y-y-eventhandler">Auxiliares (EventHandler y  y EventHandler<T>)</h3>
<p>De nueva cuenta, y al igual que con <a href="../func-y-action-en-c-sharp">Func y Action</a>, C# nos ofrece dos tipos auxiliares de delegado: <code>EventHandler</code> y <code>EventHandler&lt;T&gt;</code>, esto para no tener que definir delegados para cada evento en nuestro código.</p>
<h4 id="declaracion">Declaración</h4>
<p>Para declararlo:</p>
<pre><code class="language-csharp">public event EventHandler GeneratingNumber1;
</code></pre>
<h4 id="manejo">Manejo</h4>
<p>El delegado <code>EventHandler</code> indica que el método devuelve <code>void</code> y recibe una instancia de <code>object</code> y una de <code>EventArgs</code> como parámetros... sí, un poco complicado, pero tiene sus razones. De nuevo, mira a la forma de asignar un manejador, en esta ocasión estamos <a href="../lambdas-en-c-sharp">usando una lambda</a>:</p>
<pre><code class="language-csharp">g.GeneratingNumber1 += (sender, e) =&gt; 
{
    var generador = sender as Generator;
    Console.WriteLine(generador.Name + &quot; generará un número (EventHandler)&quot;);
};
</code></pre>
<p>Comúnmente el parámetro <code>sender</code> es una referencia al objeto que lanzó el evento, es por eso que se puede hacer el <em>cast</em> a <code>Generator</code> sin problema.</p>
<h4 id="invocacion">Invocación</h4>
<p>La invocación no varía mucho, igual hay que checar que no sea nulo antes de llamar al <code>event</code>, solo que esta vez es necesario pasar dos argumentos:</p>
<ul>
<li><code>this</code> que hace referencia a quién genera el evento, y</li>
<li><code>EventArgs.Empty</code></li>
</ul>
<pre><code class="language-csharp">if (GeneratingNumber1 != null)
{
    GeneratingNumber1(this, EventArgs.Empty);
}
</code></pre>
<h3 id="eventos-con-informacion-extra-eventhandler">Eventos con información extra (EventHandler<T>)</h3>
<p>Hay ocasiones en que los eventos por si mismos sean solo una parte de la información, por ejemplo: imagina que de nuestro generador de números aleatorios queremos saber cuándo se genera un número par, y saber cuál es el número par que se generó. Es ahí cuando podemos hacer uso de <code>EventHandler&lt;T&gt;</code>:</p>
<h4 id="declaracion-1">Declaración</h4>
<pre><code class="language-csharp">public event EventHandler&lt;int&gt; EvenNumberGenerated;
</code></pre>
<h4 id="manejo-1">Manejo</h4>
<pre><code class="language-csharp">g.EvenNumberGenerated += (sender, number) =&gt; 
{
    Console.WriteLine(&quot;Se generó el número par: &quot; + number + &quot; (manejador 1)&quot;);
};
</code></pre>
<h4 id="multiples-manejadores">Múltiples manejadores</h4>
<p>Hay ocasiones en que para un mismo evento existen muchos suscriptores. Para suscribir más de un manejador de evento basta con seguir utilizando el operador <code>+=</code></p>
<pre><code class="language-csharp">// Método para el manejador
static void G_EvenNumberGenerated(object sender, int number)
{
    Console.Write(&quot;Se generó el número par&quot; + number + &quot; (manejador 2)&quot;);
    if (number % 7 == 0)
    {
        Console.Write(&quot; que además es múltiplo de 7, bye bye!&quot;);
        g.EvenNumberGenerated -= G_EvenNumberGenerated;
    }
    Console.WriteLine();
}

// Suscripción del manejador  
g.EvenNumberGenerated += G_EvenNumberGenerated;  
</code></pre>
<h4 id="invocacion-1">Invocación</h4>
<p>Ahora, para invocar un evento de este tipo es necesario usar como argumentos el objeto que lo provoca y el valor asociado con el evento:</p>
<pre><code class="language-csharp">var generated = r.Next();

if (generated % 2 == 0)
{
    if (EvenNumberGenerated != null)
    {
        EvenNumberGenerated(this, generated);
    }
    // ...
</code></pre>
<p>Tras lo cual, el resultado de ejecutar el programa es el siguiente:</p>
<pre>
Leña generará un número
Leña generará un número (EventHandler)
Se generó el número par: 1817673842 (manejador 1)
Se generó el número par1817673842 (manejador 2)
Leña generará un número
Leña generará un número (EventHandler)
Se generó el número par: 1464150850 (manejador 1)
Se generó el número par1464150850 (manejador 2)
</pre>
<h3 id="desuscribiendose-de-eventos">Desuscribiéndose de eventos</h3>
<p>Así como podemos suscribirnos a eventos, también es posible hacer lo contrario: desuscribirse de los eventos. Nos desuscribimos de un evento cuando no queremos seguir al tanto de su invocación.</p>
<p>Para desuscribimos usamos el operador <code>-=</code> junto con el manejador de evento con el que nos suscribimos:</p>
<pre><code class="language-csharp">g.EvenNumberGenerated -= G_EvenNumberGenerated;
</code></pre>
<p>Si en tu código tendrás que desuscribir eventos, lo ideal es que los declares como métodos con nombre, no lambdas y no delegados, ya que es más natural <a href="http://stackoverflow.com/questions/183367/unsubscribe-anonymous-method-in-c-sharp" target="_blank">remover un manejador</a> que uno anónimo.</p>
<h3 id="por-que-no-usar-un-delegado">¿Por qué no usar un delegado?</h3>
<p>Una de las preguntas que te podrían surgir es ¿por qué no usar solamente un <code>delegate</code> en lugar de la sintaxis extra de los <code>event</code>?</p>
<p>La respuesta es un tanto sencilla, además del valor semántico que le da un evento a tu código, los eventos tienen dos características:</p>
<ul>
<li>Solamente pueden ser invocados dentro del objeto al que pertenecen.</li>
<li>Únicamente pueden ser eliminados (igualados a <code>null</code>) dentro del objeto al que pertenecen.</li>
</ul>
<p>O, en código:</p>
<pre><code class="language-csharp">// Dentro de la clase Generator
public Action&lt;int&gt; EvenNumberGeneratedAction;

//  Fuera de la clase Generator			
//g.EvenNumberGenerated(5); // No se puede ejecutar el evento desde &quot;afuera&quot;
g.EvenNumberGeneratedAction(3);

//g.EvenNumberGenerated = null; // No se puede &quot;eliminar&quot; a todos los manejadores desde fuera  
g.EvenNumberGeneratedAction = null;
</code></pre>
<h3 id="conclusion">Conclusión</h3>
<p>Los eventos son de mucha importancia cuando se programan aplicaciones en C#, y más aún cuando se tiene que reaccionar a cambios en un objeto o cuando debemos estar al tanto de interacciones con los usuarios. Conocer qué es lo que tienen detrás y cómo es que se declaran, invocan y manejan debería estar en el repertorio de todo desarrollador en C#.</p>


            </div>
          </div>
        
</body>
</html>
