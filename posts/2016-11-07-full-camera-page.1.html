<!DOCTYPE html>
<html lang=""  itemscope itemtype="http://schema.org/Blog">
<head>
        <!–– Made with Lockdown: https://github.com/fferegrino/lockdown ––>
<meta charset="utf-8" />
<link rel="stylesheet" href="/css/main.css" />

        
</head>

<body>  
        <header class="site-header ui">
    <div class="wrapper menu">
      <nav class="site-nav">
        <a href="#" class="menu-icon">
          <svg viewBox="0 0 18 15">
            <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
            <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
            <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
          </svg>
        </a>
        <div class="trigger">
          <a class="link page-link" href="/">Home</a>
          <a class="link page-link" href="/about">About</a>
          <a class="link page-link" href="/search">Search</a>
        </div>
      </nav>
    </div>
    <div class="wrapper title">
      <div class="pure-g">
        <div class="pure-u-1-24 title-number"><span>1</span></div>
        <div class="pure-u-11-24 content-window">
          <a class="site-title" href="/">That C# guy</a>
        </div>
        <div class="pure-u-12-24 header-menu">
          <ul>
            <li class="datascience"><a href="/tag/data-science/">Data Science!</a></li>
            <li class="youtube"><a href="https://www.youtube.com/c/thatcsharpguy">YouTube<a></li>
            <li class="csharp"><a href="/tag/aprendecsharp/">Aprende C#</a></li>
            <li class="xamarin"><a href="/tag/xamarin/">Xamarin</a></li>
          </ul>
        </div>
      </div>
  
  </header>
        <div class="page-content">
            <div class="wrapper">
                
<h1></h1>

<p>It has been a while since I coded <a href="..\Aharphat-Android" target="_blank">CharpHat</a>, which is an app that lets you snap a picture of anything and then put a nice C# graduation cap on it. That app was far from perfect, but it helped me to practice the usage of custom page renderers.</p>
<p>Today I decided to retake that project, but this time trying to isolate the code needed to build the interface and funcionality of the page, so that anyone looking forward to implement a full camera page in their apps could reuse the code for their own projects. So be sure to <strong><a href="https://github.com/ThatCSharpGuy/Forms-FullCameraPage" target="_blank">grab the source code</a></strong> for this post.</p>
<h2 id="forms-abstractions">Forms abstractions</h2>
<p><small><a href="https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/CameraPage.cs" target="_blank">Here is the source code for this section.</a></small></p>
<p>Let's start by creating the Xamarin.Forms page that will serve as our point of interaction with the custom code:</p>
<pre><code class="language-csharp">public class CameraPage : ContentPage
{
    public delegate void PhotoResultEventHandler(PhotoResultEventArgs result);
    public event PhotoResultEventHandler OnPhotoResult;
</code></pre>
<p>Business as usual, create a class deriving from <code>ContentPage</code>. I have added an event handler as I want to access the picture taken by the user. Now let's throw in some methods to call whenever an user performs an action in our camera page (in this case, the user will be allowed to take a photo or cancel the action):</p>
<pre><code class="language-csharp">public void SetPhotoResult(byte[] image, int width = -1, int height = -1)
{
    OnPhotoResult?.Invoke(new PhotoResultEventArgs(image, width, height));
}

public void Cancel()
{
    OnPhotoResult?.Invoke(new PhotoResultEventArgs());
} 
</code></pre>
<p>For reference, see the properties inside the <code>PhotoResultEventArgs</code> class:</p>
<pre><code class="language-csharp">public bool Success { get; private set; }
public int Width { get; private set; }
public int Height { get; private set; }
public byte[] Image { get; private set; }
</code></pre>
<p>Now, time to move on to the platform specifics.</p>
<h2 id="in-xamarin.ios">In Xamarin.iOS</h2>
<p><small><a href="https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/iOS/CameraPageRenderer.cs" target="_blank">Here is the source code for this section.</a></small></p>
<p>To be honest, this implementation is the easiest by far. Start off by creating a class that inherits from <code>PageRenderer</code>, and to add the <code>ExportRenderer</code> attribute:</p>
<pre><code class="language-csharp">[assembly: ExportRenderer(typeof(CameraPage), typeof(CameraPageRenderer))]
namespace FullCameraPage.iOS
{
	public class CameraPageRenderer : PageRenderer
</code></pre>
<p>Now, an this is very important, you need to override the <code>ViewDidLoad</code> method, since it gets called as soon as our page is loaded by the iOS mechanisms. For the sake of organisation let's split the code in several other methods:</p>
<pre><code class="language-csharp">public override async void ViewDidLoad()
{
    base.ViewDidLoad();
    SetupUserInterface();
    SetupEventHandlers();
    AuthorizeCameraUse();
    SetupLiveCameraStream();
}
</code></pre>
<h3 id="setupuserinterface">SetupUserInterface</h3>
<p>As the name states, here is where you need to build the UI. As you may have guessed, it is all done by code, but don't worry, it is very easy... as long as your UI isn't so complex, but you can do whatever you need here.</p>
<p>For this sample the UI will consist of a couple of buttons and a surface where the live preview from the camera is going to be shown, so you need to declare them on a class-level scope:</p>
<pre><code class="language-csharp">VectorButton takePhotoButton;
VectorButton cancelPhotoButton;
UIView liveCameraStream;
</code></pre>
<p>To set the items in place you need to think as if you were working with a relative layout, meaning that you need to set the position of each item within the screen. For example, look at how the live camera preview view is positioned:</p>
<pre><code class="language-csharp">private void SetupUserInterface()
{
    // Code ommited ...
    liveCameraStream = new UIView()
    {
        Frame = new CGRect(0f, 0f, View.Bounds.Width, View.Bounds.Height)
    };
    // Code ommited ...
    View.Add(liveCameraStream);
    // Code ommited ...
}
</code></pre>
<h3 id="setupeventhandlers">SetupEventHandlers</h3>
<p>Now that the UI has been built, let's hook up the event handlers to each control, luckly for this sample there are only two buttons on screen: one to take the picture and the other to cancel the whole thing.</p>
<pre><code class="language-csharp">cancelPhotoButton.TouchUpInside += (s, e) =&gt;
{
    (Element as CameraPage).Cancel();
};

takePhotoButton.TouchUpInside += async (s, e) =&gt;
{
    var data = await CapturePhoto();
    UIImage imageInfo = new UIImage(data);

    (Element as CameraPage).SetPhotoResult(data.ToArray(),
                                           (int)imageInfo.Size.Width,
                                           (int)imageInfo.Size.Height);
};
</code></pre>
<p>The property <code>Element</code> contains a reference to the page associated to the renderer, and is our way to interact with our Forms project. As for the method <code>CapturePhoto</code>... we'll see it later.</p>
<h2 id="authorizecamerause">AuthorizeCameraUse</h2>
<p>Now it's time to ask the user for its permission to access the camera:</p>
<pre><code class="language-csharp">var authorizationStatus = AVCaptureDevice.GetAuthorizationStatus(AVMediaType.Video);
if (authorizationStatus != AVAuthorizationStatus.Authorized)
{
    await AVCaptureDevice.RequestAccessForMediaTypeAsync(AVMediaType.Video);
}
</code></pre>
<p>But wait a minute, before executing the code above, make sure you have added the key <code>Privacy - Camera Usage Description</code> to the Info.plist in your project.</p>
<h3 id="setuplivecamerastream">SetupLiveCameraStream</h3>
<p>Now the &quot;heavy&quot; stuff.</p>
<p>Start by declaring at class-level scope an <code>AVCaptureSession</code>, <code>AVCaptureDeviceInput</code> and <code>AVCaptureStillImageOutput</code>, as they will hel us access the camera, display the live feed and capture the photo.</p>
<p>Then, inside the <code>SetupLiveCameraStream</code> method, initialize the capture session, create a preview layer with the same size as our <code>liveCameraStream</code>, and add it as a sublayer of it:</p>
<pre><code class="language-csharp">    captureSession = new AVCaptureSession();
    var videoPreviewLayer = new AVCaptureVideoPreviewLayer(captureSession)
    {
        Frame = liveCameraStream.Bounds
    };
    liveCameraStream.Layer.AddSublayer(videoPreviewLayer);
</code></pre>
<p>Next, &quot;create&quot; a capture device (you can configure it to work according to your needs). And then, from it create the an input source for the capture session:</p>
<pre><code class="language-csharp">    var captureDevice = AVCaptureDevice.DefaultDeviceWithMediaType(AVMediaType.Video);
    ConfigureCameraForDevice(captureDevice);
    captureDeviceInput = AVCaptureDeviceInput.FromDevice(captureDevice);
</code></pre>
<p>We have an input (the camera of the device), now we need an output which is going to be a jpeg photograph:</p>
<pre><code class="language-csharp">    var dictionary = new NSMutableDictionary();
    dictionary[AVVideo.CodecKey] = new NSNumber((int)AVVideoCodec.JPEG);
    stillImageOutput = new AVCaptureStillImageOutput()
    {
        OutputSettings = new NSDictionary()
    };
</code></pre>
<p>Finalize by setting the input and output of the capture session and starting it:</p>
<pre><code class="language-csharp">    captureSession.AddOutput(stillImageOutput);
    captureSession.AddInput(captureDeviceInput);
    captureSession.StartRunning();
</code></pre>
<h3 id="capturephoto">CapturePhoto</h3>
<p>At last, the icing on the cake, the code to capture the photo. The code is pretty simple: Take the output and capture a still image from it, as we only need the bytes we get an <code>NSData</code> containing the taken photo.</p>
<pre><code class="language-csharp">public async Task&lt;NSData&gt; CapturePhoto()
{
    var videoConnection = stillImageOutput.ConnectionFromMediaType(AVMediaType.Video);
    var sampleBuffer = await stillImageOutput.CaptureStillImageTaskAsync(videoConnection);
    var jpegImageAsNsData = AVCaptureStillImageOutput.JpegStillToNSData(sampleBuffer);
    return jpegImageAsNsData;
}
</code></pre>
<h2 id="in-xamarin.android">In Xamarin.Android</h2>
<p><small><a href="https://github.com/ThatCSharpGuy/Forms-FullCameraPage/blob/master/Droid/CameraPageRenderer.cs" target="_blank">Here is the source code for this section.</a></small><br />
This implementation isn't as clean as it is in iOS. Mainly because Android puts a lot of ephasis in the use of listeners, rather than in event handlers. However, that is not a problem for us.</p>
<p>As with the iOS implementation, start by creating a new class and make it derive from <code>PageRenderer</code> and also make it implement the <code>TextureView.ISurfaceTextureListener</code> interface. Don't forget the <code>ExportRender</code> attribute:</p>
<pre><code class="language-csharp">[assembly: Xamarin.Forms.ExportRenderer(typeof(CameraPage), typeof(CameraPageRenderer))]
namespace FullCameraPage.Droid
{
    public class CameraPageRenderer : PageRenderer, TextureView.ISurfaceTextureListener
</code></pre>
<p>Then, override the <code>OnElementChanged</code> method (if you have creaated custom renderers before this method may be familar to you), this method is going to be called everytime the a <code>CamerPage</code> is shown on screen:</p>
<pre><code class="language-csharp">protected override void OnElementChanged(ElementChangedEventArgs&lt;Xamarin.Forms.Page&gt; e)
{
    base.OnElementChanged(e);
    SetupUserInterface();
    SetupEventHandlers();
</code></pre>
<h3 id="setupuserinterface-1">SetupUserInterface</h3>
<p>In this method we are supposed to create the camera page itself, you can do it by creating an <em>axml</em> file and calling all the Android inflating stuff... Or, like in this sample, you can create it by code.</p>
<p>For this sample, we'll need a <code>RelativeLayout</code> to work as a container, a <code>TextureView</code> to display the live feed from the camera, and a <code>Button</code> (a <code>PaintCodeButton</code> actually) to snap the photograph. Declare all them at class-level scope:</p>
<pre><code class="language-csharp">RelativeLayout mainLayout;
TextureView liveView;
PaintCodeButton capturePhotoButton;
</code></pre>
<p>Now, proceed to create them and add them to the screen, for example, see how we can create the container layout and add the <code>TextureView</code> to it:</p>
<pre><code class="language-csharp">void SetupUserInterface()
{
    mainLayout = new RelativeLayout(Context);
    RelativeLayout.LayoutParams mainLayoutParams = new RelativeLayout.LayoutParams(
        RelativeLayout.LayoutParams.MatchParent,
        RelativeLayout.LayoutParams.MatchParent);
    mainLayout.LayoutParameters = mainLayoutParams;

    liveView = new TextureView(Context);
    RelativeLayout.LayoutParams liveViewParams = new RelativeLayout.LayoutParams(
        RelativeLayout.LayoutParams.MatchParent, 
        RelativeLayout.LayoutParams.MatchParent);
    liveView.LayoutParameters = liveViewParams;
    mainLayout.AddView(liveView);
    
    // Code ommited...

    AddView(mainLayout);
}
</code></pre>
<p>Before continuing, there is another method (<code>OnLayout</code>) we need to override to give our main layout it's size (and acommodate the UI accordingly):</p>
<pre><code class="language-csharp">protected override void OnLayout(bool changed, int l, int t, int r, int b)
{
    base.OnLayout(changed, l, t, r, b);
    if (!changed)
        return;
    var msw = MeasureSpec.MakeMeasureSpec(r - l, MeasureSpecMode.Exactly);
    var msh = MeasureSpec.MakeMeasureSpec(b - t, MeasureSpecMode.Exactly);
    mainLayout.Measure(msw, msh);
    mainLayout.Layout(0, 0, r - l, b - t);

    capturePhotoButton.SetX( mainLayout.Width / 2 - 60);
    capturePhotoButton.SetY(mainLayout.Height - 200);
}
</code></pre>
<h3 id="setupeventhandlers-1">SetupEventHandlers</h3>
<p>As I said, Android relies mostly on event listeners rather than handlers, so the code for this method is pretty simple. We need to set an event handler for the &quot;sutter&quot; button and assign the listener that will be aware of the <code>SurfaceTexture</code> status (remember that our page render implements an interface?):</p>
<pre><code class="language-csharp">capturePhotoButton.Click += async (sender, e) =&gt;
{
    var bytes = await TakePhoto();
    (Element as CameraPage).SetPhotoResult(bytes, liveView.Bitmap.Width, liveView.Bitmap.Height);
};
liveView.SurfaceTextureListener = this;
</code></pre>
<p>And one more thing, let's to override the default behavior of the &quot;back&quot; button, so that it acts as a cancel button for the camera:</p>
<pre><code class="language-csharp">public override bool OnKeyDown(Keycode keyCode, KeyEvent e)
{
    if (keyCode == Keycode.Back)
    {
        (Element as CameraPage).Cancel();
        return false;
    }
    return base.OnKeyDown(keyCode, e);
}
</code></pre>
<h3 id="textureview.isurfacetexturelistener-implementation">TextureView.ISurfaceTextureListener implementation</h3>
<p>Now is time to implement the core of our page. Start by writing the code for the <code>OnSurfaceTextureAvailable</code> where we will prepare the output for the camera, but first we'll need a camera, right?</p>
<p>At class-level scope declare a <code>Camera</code>:</p>
<pre><code class="language-csharp">Android.Hardware.Camera camera;
</code></pre>
<p>Inside the method, open the camera (by default it'll try to open the back camera of the device) and get its parameters. We need them to select the right preview size, because we want things to look great in our app:</p>
<pre><code class="language-csharp">camera = Android.Hardware.Camera.Open();
var parameters = camera.GetParameters();
</code></pre>
<p>Once we have the parameters at hand, we can get the avaliable <code>PreviewSizes</code> and get the one that fits our preview surface. In this case I'm using a simple <a href="#">linq expression</a> to get the best preview size based on aspect ratio:</p>
<pre><code class="language-csharp">var aspect = ((decimal)height) / ((decimal)width);

var previewSize = parameters.SupportedPreviewSizes
                            .OrderBy(s =&gt; Math.Abs(s.Width / (decimal)s.Height - aspect))
                            .First();

parameters.SetPreviewSize(previewSize.Width, previewSize.Height);
camera.SetParameters(parameters);
</code></pre>
<p>Finish by setting our surface as the preview texture, at this point the only thing left to do is to start the camera:</p>
<pre><code class="language-csharp">camera.SetPreviewTexture(surface);
StartCamera();
</code></pre>
<p>The other method we need to write code into is <code>OnSurfaceTextureDestroyed</code> in order to stop the camera, so just write the following inside and it'll be all:</p>
<pre><code class="language-csharp">StopCamera();
return true;
</code></pre>
<h3 id="startcamera-and-stopcamera">StartCamera and StopCamera</h3>
<p>These two methods are quite simple too, for <code>StartCamera</code> we only need to rotate the preview to make it look right in the screen (in this case I'm setting it to be viewed vertically), and then finally, start the camera:</p>
<pre><code class="language-csharp">camera.SetDisplayOrientation(90);
camera.StartPreview();
</code></pre>
<p>The <code>StopCamera</code> method stops the preview and releases the camera, so that other apps can access to it:</p>
<pre><code class="language-csharp">camera.StopPreview();
camera.Release();
</code></pre>
<h3 id="takephoto">TakePhoto</h3>
<p>In order to get a photo, the only thing we need to do is get an sitll image from the live feed presented in the <code>TextureView</code>, here is the code to do so and then return the image in bytes:</p>
<pre><code class="language-csharp">camera.StopPreview();
var ratio = ((decimal)Height) / Width;
var image = Bitmap.CreateBitmap(liveView.Bitmap, 0, 0, liveView.Bitmap.Width, (int)(liveView.Bitmap.Width * ratio));
byte[] imageBytes = null;
using (var imageStream = new System.IO.MemoryStream())
{
    await image.CompressAsync(Bitmap.CompressFormat.Jpeg, 50, imageStream);
    image.Recycle();
    imageBytes = imageStream.ToArray();
}
camera.StartPreview();
return imageBytes;
</code></pre>
<p>And that's it, after all that code, you can now make use of this camera page. Keep reading to find a sample usage code:</p>
<h2 id="usage-in-forms">Usage in Forms</h2>
<pre><code class="language-csharp">var cameraPage = new CameraPage();
cameraPage.OnPhotoResult += CameraPage_OnPhotoResult;
Navigation.PushModalAsync(cameraPage);  
// ...
async void CameraPage_OnPhotoResult(Pages.PhotoResultEventArgs result)
{
    await Navigation.PopModalAsync();
    if (!result.Success)
        return;
    Image.Source = ImageSource.FromStream(() =&gt; new MemoryStream(result.Image));
</code></pre>
<p>If you <strong><a href="https://github.com/ThatCSharpGuy/Forms-FullCameraPage" target="_blank">download the source code</a></strong> and run it, you will see something like this:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/DgFEK9tPKs0" frameborder="0" allowfullscreen></iframe>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>The code for this post was entirely based on the code from the <a href="..\Aharphat-Android" target="_blank">CharpHat</a>, which at the same time was based on the <a href="https://blog.xamarin.com/build-your-own-snapchat-clone-with-xamarin-forms-and-azure/" target="_blank">Moments app</a> by <a href="https://github.com/pierceboggan" target="_blank">Pierce Boggan</a>.</p>


            </div>
          </div>
        
</body>
</html>
